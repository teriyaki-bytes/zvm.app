---
title: How to Build C/C++ Projects with Zig Build
description: "How to configure build.zig for C/C++ projects."
---

# How to build C/C++ projects with Zig Build

[Zig](https://ziglang.org) is a low-level programming language inspired by C.
One of its aims is to integrate into existing C and C++ projects as a build
tool, bundling an LLVM C and C++ compiler with the language that supports cross
compilation, automatic caching, and integrated tests. It's one of the most
innovative new languages this decade, but suffers from being young and in active
development.

Zig seriously lacks user-focused documentation. Beyond an overwhelming--_and
experimental_--corpus of standard library and language documentation, most of
what you've read about Zig is already out of date. At the time of writing, Zig
is actively developing version 0.12, nowhere close to a stable, production-ready
1.0. But that doesn't mean you can't trust Zig as a build tool. Their C/C++
tools are top notch, stable, and `zig build`, the languages integrated build
tool is mature enough to be depended on if you can keep up with its syntax. In
this guide, I'm going to show you how to download zig and configure a C/C++
project using Zig Build.

## Download Zig

When using Zig, it's important to keep your installation up to date with Master.
Most developers you'll find on the Discord or in forum are using the latest
version of Zig, and sticking with an older version of a language before a stable
1.0 is a recipe for dependability disasters. I recommend using
[ZVM](https://zvm.app). Disclaimer, I created the project and actively maintain
it, but its found wide adoption within the Zig community, is ultra portable, and
offers unique features you can't get from other version managers like a
self-updater, the ability to lock your Zig version on a project-by-project
basis, and more!

### Install ZVM

Run the following curl script to install and configure ZVM on MacOS, Linux, or
any \*nix system. If you use Windows, please follow the guide on the
[ZVM install page](https://www.zvm.app/guide/install.html).

```sh
curl https://raw.githubusercontent.com/tristanisham/zvm/master/install.sh | bash
```

### Add ZVM and Zig to your PATH

```sh
echo "# ZVM" >> $HOME/.profile
echo export ZVM_INSTALL="$HOME/.zvm/self" >> $HOME/.profile
echo export PATH="$PATH:$HOME/.zvm/bin" >> $HOME/.profile
echo export PATH="$PATH:$ZVM_INSTALL/" >> $HOME/.profile
```

### Installing Zig

Having setup ZVM, installing ZIG is as easy as:

```sh
zvm i master
```

Run this command anytime you'd like to update your Zig. The language maintainers
usually push new updates daily, so it's a good idea to add this script to a 24
hour cronjob.

## Using Zig Build

To get starting with Zig Build, enter an existing C/C++ project or an empty
directory and run `zig init-exe`. This is a non-destructive command and will
create the following in your current directory.

- `src/main.zig`
- `build.zig`

For this tutorial, we won't actually be using Zig to write our program so you
can delete `src/main.zig`.

### The Default Zig Build

Opening the `build.zig` generated by Zig `0.12.0-dev.415+5af5d87ad`, you'll see
that by default, Zig's build tool is written in Zig itself.

```
const std = @import("std");

// Although this function looks imperative, note that its job is to
// declaratively construct a build graph that will be executed by an external
// runner.0
pub fn build(b: *std.Build) void {
    // Standard target options allows the person running `zig build` to choose
    // what target to build for. Here we do not override the defaults, which
    // means any target is allowed, and the default is native. Other options
    // for restricting supported target set are available.
    const target = b.standardTargetOptions(.{});

    // Standard optimization options allow the person running `zig build` to select
    // between Debug, ReleaseSafe, ReleaseFast, and ReleaseSmall. Here we do not
    // set a preferred release mode, allowing the user to decide how to optimize.
    const optimize = b.standardOptimizeOption(.{});

    const exe = b.addExecutable(.{
        .name = "your-dirs-name",
        // In this case the main source file is merely a path, however, in more
        // complicated build scripts, this could be a generated file.
        .root_source_file = .{ .path = "src/main.zig" },
        .target = target,
        .optimize = optimize,
    });

    // This declares intent for the executable to be installed into the
    // standard location when the user invokes the "install" step (the default
    // step when running `zig build`).
    b.installArtifact(exe);

    // This *creates* a Run step in the build graph, to be executed when another
    // step is evaluated that depends on it. The next line below will establish
    // such a dependency.
    const run_cmd = b.addRunArtifact(exe);

    // By making the run step depend on the install step, it will be run from the
    // installation directory rather than directly from within the cache directory.
    // This is not necessary, however, if the application depends on other installed
    // files, this ensures they will be present and in the expected location.
    run_cmd.step.dependOn(b.getInstallStep());

    // This allows the user to pass arguments to the application in the build
    // command itself, like this: `zig build run -- arg1 arg2 etc`
    if (b.args) |args| {
        run_cmd.addArgs(args);
    }

    // This creates a build step. It will be visible in the `zig build --help` menu,
    // and can be selected like this: `zig build run`
    // This will evaluate the `run` step rather than the default, which is "install".
    const run_step = b.step("run", "Run the app");
    run_step.dependOn(&run_cmd.step);

    // Creates a step for unit testing. This only builds the test executable
    // but does not run it.
    const unit_tests = b.addTest(.{
        .root_source_file = .{ .path = "src/main.zig" },
        .target = target,
        .optimize = optimize,
    });

    const run_unit_tests = b.addRunArtifact(unit_tests);

    // Similar to creating the run step earlier, this exposes a `test` step to
    // the `zig build --help` menu, providing a way for the user to request
    // running the unit tests.
    const test_step = b.step("test", "Run unit tests");
    test_step.dependOn(&run_unit_tests.step);
}
```

Let's break this down line by line, then configure it for C/C++!

### Target and Optimization

A good place to start when customizing your `build.zig` file is your target and
its optimization level. Think of your target as the platform you'd like to build
for, be it Linux x86, Windows Arm, or RISC V.

```
// Standard target options allows the person running `zig build` to choose
// what target to build for. Here we do not override the defaults, which
// means any target is allowed, and the default is native. Other options
// for restricting supported target set are available.
const target = b.standardTargetOptions(.{});
```

It's a good idea to leave this value as is. This will allow you to pass your
target argument from the command line.

Optimize is similar, though be warned, there are different flags depending on
how you're building your project. Using Zig Build is not the same as using the
dedicated command line build arguments.

```
// Standard optimization options allow the person running `zig build` to select
// between Debug, ReleaseSafe, ReleaseFast, and ReleaseSmall. Here we do not
// set a preferred release mode, allowing the user to decide how to optimize.
const optimize = b.standardOptimizeOption(.{});
```

For now, let's just leave it alone.

### Configuring a Library with Zig Build

Okay, we've setup our `build.zig` file and are ready to configure it for C/C++.
Before we start editing, its important to know how Zig Build differs from tools
you may be used to like CMake and Make.

#### C and C++ Require Separate Build Steps Languages

If you have C and C++ files in your project, you will have to create seperate
build steps in `build.zig`. You can still link them together, as shown below.
Zig will error out if you try to combine them in one step.

#### Verbosity

Zig has very verbose error messages and it can be easy to get lost when trying
to diagnose why your program won't compile. This is a friendly reminder to read
the full error output. Zig is more verbose than Cargo.

### Your File Structure

```fs
./include
	cli.hpp
	lib.h
./src
    ./ cdep
	    dep.c
		mod.c
		oof.c
    ./ cli
		help.cpp
    main.cpp
build.zig

4 directories, 7 files
```

Lets say this is your project. You're building an executable that depends on
statically linking to a C dependency. The dependency's files live in
`src/cdep/`. How fitting. All of your project's header files live in `include/`,
and your program's entry point is `src/main.cpp`.

Here's how you'd configure Zig Build to compile this application. Clear out
everything in your `build.zig` file after the variable `optimize` in the
`pub fn build` function.

#### Building a Static (or Dynamic) Library

Inside your `pub fn build`, create append the following `lib` variable. The
process for creating a static vs dynamic library is nearly identical, with the
method `addStaticLibrary` being replaced by `addDynamicLibrary`.

```
const std = @import("std");
// Examples: https://github.com/floooh/sokol-tools/blob/master/build.zig

// Although this function looks imperative, note that its job is to
// declaratively construct a build graph that will be executed by an external
// runner.
pub fn build(b: *std.Build) void {
    // ... everything shown previously (target, optimize)
	// Create a dynamic library by replacing ðŸ‘‡ with `addDynamicLibrary`
    const lib = b.addStaticLibrary(.{
        .name = "cdep",
        .target = target,
        .optimize = optimize,
        .link_libc = true,
    });
    lib.addIncludePath(.{
        .path = "include/"
    });
    lib.linkLibCpp();
    lib.addCSourceFiles(&.{ // files
        "src/cdep/dep.c",
        "src/cdep/std/mod.c",
        "src/cdep/std/oof.c",

    }, &.{ // flags. Leave empty if you don't have any flags to pass.
        "-pedantic",
        "-Wall",
        "-W",
        "-Wno-missing-field-initializers",
        "--std=c99",
    });
    
	b.installArtifact(lib);
    // continued...

}
```

### Linking it to Your Executable

After you've defined `lib`, create and append the following inside of the
`pub fn build` definition.

```
// ... everything shown previously (target, optimize, lib)

    const exe = b.addExecutable(.{
        .name = "yourExe", // change this to whatever your executable should be called.
        .target = target,
        .optimize = optimize,
    });
    exe.addIncludePath(.{
        .path = "include"
    });
    exe.linkLibCpp();
    exe.linkLibrary(lib); // link to the lib library we created in the last step
    exe.addCSourceFiles(&.{
        "src/main.cpp",
        "src/cli/help.cpp"
    }, &.{ // flags
        "-pedantic",
        "-Wall",
        "-W",
        "-Wno-missing-field-initializers",
        "--std=c++20",
    });

    // This declares intent for the executable to be installed into the
    // standard location when the user invokes the "install" step (the default
    // step when running `zig build`).
    b.installArtifact(exe);

	// Continued...
```

And that's it! Run `zig build` and Zig will compile and link together your C/C++
project! You should find your output in the newly created `zig-out` directory.
Treat this like `build` or `out` and exclude it from your version control along
with the newly generated `zig-cache` directory.

```gitignore
# .gitignore
zig-out/
zig-cache/
```
